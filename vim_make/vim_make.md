# Разработка в консоли с использованием vim и make

updated: Nov 6, 2017

## Введение
Ира проходит [курс С++ от Яндекса][1] на компьютере с предустановленной _Ubuntu_. Отдельный видеоурок курса посвящён установке и настройке _IDE_ (интегрированной среды разработки) _Eclipse_, с которой у нас что-то не сложилось. Я предположил, что во время этого курса не будет проектов размером больше одного файла, поэтому всю работу можно будет выполнить в консоли. Покажу, как я обычно изучаю новое и экспериментирую с языками программирования при помощи _make_ и _vim_. Сначала напишу про `C++`, затем о юнит-тестировании в `Pyhton`.
disclaimer: **vim - не IDE.**

<img src="orly_cat.jpg" alt="все любят котиков" style="width: 300px;"/>




## "hello world" на C++17 



### Подготовка

Устанавливаем нужные пакеты нужных версий. Например, чтобы прикоснуться к С++17, нам понадобится _gcc_ седьмой версии, соответствующий фронтенд, библиотеки и хедеры. Документация тоже будет не лишней (любители графических интерфейсов могут подсунуть веб-серверу папку `/usr/share/doc/g++-7/libstdc++` , повелители командной строки набирают `man 3 std::smth` )

```# apt install gcc-7-base g++-7 libgcc-7-dev libstdc++-7-dev libstdc++-7-doc```

Пишем hello world C++17-style ([источник][2])

```cpp
//1.cpp
#include <iostream>

int main()
{
  std::string str = "hello";
  char *p = str.data(); // С++17
  p[0] = 'H';
  std::cout << str << '\n'; // Hello

  return 0;
}
```

Компилируем и соберём исполняемый файл, проверяем что получилось.

```bash
$ g++-7 -o exe 1.cpp -g -std=c++17
$ ./exe
Hello
```

В принципе, можно работать, если вас устраивает следующий цикл: сохранить изменения, выйти из текстового редактора, получить и запустить исполняемый файл двумя командами (легко объединяются в одну с помощью _&&_ ).




### make

Для сокращения числа рутинных операций задействуем утилиту _make_, которая знает как создавать одни файлы(цели) на основе других(зависимостей) по заданным правилам. Перед выполнением правила _make_ убедится, что указанные зависимости а) существуют как одноимённые файлы или б) существуют правила, на основе которых такие файлы могут быть получены и применит их (так обычно получаются недостающие библиотеки-зависимости перед сборкой исполняемого файла). Кроме того, _make_ проанализирует время обновления зависимостей и не будет предпринимать никаких действий, если целевой файл обновлялся позже любого файла, от которого зависит.

```make
#makefile naive
exe: 1.cpp makefile               #1
	g++-7 -o exe 1.cpp -std=c++17 #2
	./exe                         #3
```

На первой строке объявляем цель _exe_, зависящую от файлов _1.cpp_ и _makefile_, теперь для сборки и исполнения файла _exe_ достаточно набрать _make exe_. Так как _exe_ - первая цель в нашем _makefile_, то можно даже набирать просто _make_. На второй и третьей строке записаны правила, следуя которым мы получим нужный файл и проведём над ним какие-то действия.

Вышеописанный _makefile_ достаточно наивен. Например, слово _exe_ встречается трижды - а вдруг нам понадобится изменить имя итогового файла? Или например, нужно будет скомпилировать не один, а несколько исходных файлов - придётся дублировать список зависимостей в строке правил? Для решения этих проблем воспользоваться переменными _make_, ну и добавим пару фишечек.

```make
#makefile ok
.PHONY: exe                    #1
exe: 1.cpp                     #2
	@g++-7 -o $@ $< -std=c++17 #3
	@./$@                      #4
```

Построчный разбор _makefile_
1\. Объявим цель _exe_ фиктивной для того, чтобы каждый раз создавать файл _exe_ заново, даже если исходный файл _1.cpp_ и _makefile_ не менялись с момента создания последней версии _exe_. Это приемлемо для нашего однофайлового проекта, но не надо так делать на большом проекте, автоматическая проверка времени обновления зависимостей существенно ускоряет сборку. Польза ощущается при изменении каких-то внешних условий - например при экспериментах с заменами в системе версий подключаемой библиотеки. Мы обычно не указываем системные библиотеки в списке зависимостей, только в правилах, а если бы и указали, то это не помогло бы - чаще всего такие файлы были созданы задолго до наших экспериментов и _make_ не заметит разницы.
> В результате достижения фиктивной цели не создаётся одноименный файл. Типичная фиктивная цель - _clean_, в которой описаны правила удаления временных файлов; команда ```make clean``` (обычно) не приводит к появлению файла _clean_ и не должна ориентироваться на время его создания, если такой файл уже существует. Другая типичная фиктивная цель - _all_, при её выполнении обычно собираются все целевые файлы, и она имеет первый порядковый номер. Фиктивная цель _может_ находиться в списке зависимостей.

2\. Т.к. цель _exe_ фиктивная(т.е. пересобирается _всегда_), то больше нет смысла следить за появлением изменений в _makefile_.

3 и 4. @ в начале строки убирает из стандартного вывода строки с выполняющимися командами (мы их уже настроили и нам больше незачем на них смотреть в стандарном выводе). Так же произошли замены: _exe_ -> _\$@_, эта переменная обозначает имя цели (мнемоника - @ похожа на мишень) и _1.cpp_ -> _\$<_, эта переменная обозначает первую зависимость из списка (мнемоники не знаю, всё время путаю с переменной _\$^_, которая раскрывается в полный список зависимостей). Переменных гораздо больше, но эти три - самые полезные.



### vim

Цикл сократился до "сохранить, выйти, _make_". Если вы пишете программы, которые с первого раза работают как надо - этого достаточно. Для обычных людей это не подходит, как минимум хорошо бы сопоставлять ошибки компиляции со строками, в которых они произошли. И тут всё упирается в возможности редактора. Вызов внешней процедуры можно прикрутить даже к _mcedit_, как я когда-то делал при разработке скрипта на _Perl_. В какой-то момент я закопал стюардессу, прошёл _vimtutor_ и полюбил _vim_ за его мощь и простоту. Оцените: `:w | make`.

В одно действие сохраняем файл и выполняем встроенный вызов команды _make_. Нет необходимости открывать\закрывать редактор. Если компилятор нашёл ошибки, то _vim_ начнёт работать в "режиме" _quickfix_ - сразу перейдёт к месту первой ошибки 2) в статусной строке выведет сообщение об ошибке, 3) команды `:cnext, :cprev, :clist` служат для перехода к следующей, предыдущей, полному списку ошибок (у всех команд _vim_ есть краткий синтаксис, здесь это `:cn, :cp, :cl` соответственно). Всё, можно творить, не выходя из редактора. При сборке настоящего проекта бывает полезным перенаправить поток ошибок _make_ в отдельный файл и а) просто открыть его в виме и переходить к ошибочным строчкам исходного кода по _gF_ или б) открыть его в режиме _quickfix_: `vim -q filename`.

TODO: гифки со скринкастом сравнения работы до\после. Пока хочу в https://github.com/tav/asciinema2gif


### Тестирование

```cpp
// sum.cpp
// yield to stdout sum of 2 digits from stdin
#include <iostream>

using namespace std;

int main() {
    int x, y;
    cin >> x >> y;
    cout << x + y << endl;
    return 0;
}
```

Иркина программа считывает данные данные из входного потока. Проверку её работы можно автоматизировать следующим образом: `$ echo 1 2 | ./exe`. Если из всего вывода программы нас интересуют лишь строки, содержащие фрагмент "stmh", то отфильтруем вывод: `$ ./exe | grep smth`. Хорошо бы пользоваться юнит-тестированием, фреймворков для С++ очень многою Для настоящих проектов есть смысл подключить _cmake_ и _ctest_. Ну а мы накидаем на коленке.

```make
#makefile to sum
.PHONY: sum
sum: sum.cpp makefile
	@ g++ -o $@ $<
	@ echo 1 2 | ./$@ | grep 3 -q \
		&& echo ok || echo failed
```





## Python и юнит-тестирование

Для интерпретируемых ЯП (_Python, Perl, Bash, ..._) удобно играться с отдельными кусками вновь написанного кода, отправляя их в интерпретатор, открытый в соседнем окне мультиплексоров терминала _tmux_ или _screen_, см. [плагин vim-slime][4].

Так как для запуска программы не надо компилировать и линковать, а нужно только передать текст программы интерпретатору, то поступаем следующим образом. 
1. Ставим бит выполнения на файл: `chmod u+x filename`
1. Указываем в первой строке файла путь до интерпретатора (или просим систему саму разобраться) `#/usr/bin/env python`
1. Сохраняем файл и отправляем его на выполнение: `:w | !./%` ("!" означает "выполни команду оболочки", "%" разворачивается в имя текущего файла).

Вместо трёх предыдущих пунктов можно выполнять `:w | ! python ./%`, но тогда мы потеряем удобное выполнение файла по нажатии на _Enter_ в _mc_.

В комплекте с _Python_ идёт библиотека для юнит-тестирования _unittest_. Вот как я её использовал при решении задачи 1.6 из книги "[Карьера программиста][5]" c помощью _Python 3.5.2_.

> Реализуйте метод для выполнения простейшего сжатия строк с использованием счётчика повторяющихся символов. Например, строка `aabcccccaaa` превращается в `a2b1c5a3`. Если "сжатая" строка короче исходной, то метод возвращает исходную строку. Предполагается, что строка состоит только из букв верхнего и нижнего регистра(a-z).

Ниже код, который решает поставленную задачу. TODO: добавить генерацию исключения, если подана строка, не удовлетворяющия условию (символы кроме a-z) + перехват этого исключения в тесте.

```python
#!/usr/bin/env python3
# compressString.py

import sys # argv, stderr

def compressString(string):
  if len(string) < 3:
    return string

  current = string[0]
  llist = [current]
  count = 1

  for i in range(1, len(string)):
    if current == string[i]:
      count += 1
    else:
      llist.append(str(count))
      count = 1
      current = string[i]
      llist.append(current)

  llist.append(str(count))
  #print(llist, file=sys.stderr)

  compressed = "".join(llist)

  if len(string) <= len(compressed):
    return string
  else:
    return compressed

if __name__ == '__main__':

  if len(sys.argv) != 2:
    print ("Usage: ", sys.argv[0], '<string>');
    exit(1)

  print (compressString(sys.argv[1]))
```

Ниже тесты, с помощью которых я проверял, решает ли код выше поставленную задачу. Сначала добавил пример из книги и пару своих примеров в виде кортежа пар строк в формате "ввод" и "ожидаемый возврат". Для перезапуска тестирования выполнял команду `:wa | !./compressString_test.py`. Можно перенести выполнение внешней команды в _makefile_ и превратить команду в `wa | make`. На тему юнит-тестирования в _Python_ можно почитать [официальную документацию][7] или бесплатную [книгу][6].

```python
#!/usr/bin/env python3
# compressString_test.py

import unittest
import compressString

class KnownValues(unittest.TestCase):
  match = (
      ('aabcccccaaa','a2b1c5a3'),
      ('aaaaaaaaaa', 'a10'),
      ('aa',         'aa'),
      ('aabbcc',     'aabbcc'),
      ('aabbccc',    'a2b2c3'),
      )

  def test_known_vaules(self):
    for inp, out in self.match:
      with self.subTest(inp=inp, out=out):
        res = compressString.compressString(inp)
        self.assertEqual(res, out)

if __name__ == '__main__':
  unittest.main()
```

```bash
$ ./compressString_test.py
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
```

Для демонстрации добавим ошибку в наш список примеров и перезапустим.

```bash
$ ./compressString_test.py
======================================================================
FAIL: test_known_vaules (__main__.KnownValues) (inp='aabbccc', out='b2b2c3')
----------------------------------------------------------------------
Traceback (most recent call last):
  File "./compressString_test.py", line 20, in test_known_vaules
    self.assertEqual(res, out)
AssertionError: 'a2b2c3' != 'b2b2c3'
- a2b2c3
? ^
+ b2b2c3
? ^

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
```

В сообщении об ошибке видно, какой именно набор тестов на каком именно наборе сломался, показано точное место расхождения. Подобным образом я проверял возврат функции, содержимое вывода на экран, перехватывал исключения. Интересная функция `assertAlmostEqual(places=4, <...>)` сравнивает числа с плавающей точкой с заданной точностью.

Для упрощения упрощения тестирования решения нескольких задач одну за другой, я создал шаблон файла тестирования, в котором подставлял нужные:
 * имя тестируемого модуля и функции (с использованием псевдонима) - `import smth.func as testFunc`
 * списки входных и проверяемых данных

Для протестирования функции, принимающей несколько параметров, я в первом "столбце" тестовых данных записывал кортеж, а при передаче в функцию разворачивал его.

```python
#func
def timeConvert(h, m, s):
    ...

#test
    ...
      ((1, 2, 0), 31.0),
      ...
      res = testFunc(*inp)
    ...
```



## PS
1. Наверняка существует плагин для _vim_, который делает всё нижеописанное описанное и даже больше. На работе мне приходится работать на разных серверах под различными учётными записями, поэтому (в лучшем случае) я таскаю за собой свой _.vimrc_, и не обрастаю плагинами.
1. _vim_ очень мощный инструмент, я не описал и доли его возможностей. Например, если вы одновременно редактируете несколько файлов, то основная команда будет выглядеть следующим образом: `:wa | make`. Для любой последовательности команд можно задать почти любое сочетание клавиш, например так: `nnoremap <F5> :wa \| make<CR>`. Не пожалейте 10 минут и пройдите обучение: выполните в командной оболочке ```$ vimtutor ru``` и следуйте указаниям.
1. То же самое касается _make_. Хорошей отправной точкой в изучении _make_ может стать хабрапост ["Просто о make"][3].
1. Отладкой в консоли мне пока заниматься не доводилось, редко-редко запускаю _gdb_ по _ssh_. Увы, принты и голова - наше всё %)
1. А Ирине мы в итоге настроили QtCreator =)

[1]: https://www.coursera.org/learn/c-plus-plus-white
[2]: https://habrahabr.ru/company/pvs-studio/blog/340014/ 
[3]: https://habrahabr.ru/post/211751/
[4]: https://www.youtube.com/watch?v=fWKIVWEhyG4
[5]: https://www.ozon.ru/person/29561976/
[6]: https://habrahabr.ru/post/339764/ 
[7]: https://docs.python.org/3/library/unittest.html
