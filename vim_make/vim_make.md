#Разработка в консоли - "hello world" на C++17 с использованием vim и make

updated: Nov 5, 2017

Ира проходит [курс С++ от Яндекса][1] на компьютере с предустановленной _Ubuntu_. Отдельный видеоурок курса посвящён установке и настройке _IDE_ (интегрированной среды разработки) _Eclipse_, с которой у нас что-то не сложилось. Я предположил, что во время этого курса не будет проектов размером больше одного файла, поэтому всю работу можно будет выполнить в консоли. Предлагаю решение на основе _make_ и _vim_, которым я обычно пользуюсь для изучения и экспериментов с языками программирования. disclaimer: **vim - не IDE.**

<img src="orly_cat.jpg" alt="все любят котиков" style="width: 300px;"/>


Устанавливаем нужные пакеты нужных версий. Например, чтобы прикоснуться к С++17, нам понадобится _gcc_ седьмой версии, соответствующий фронтенд, библиотеки и хедеры. Документация тоже будет не лишней (любители графических интерфейсов могут подсунуть веб-серверу папку `/usr/share/doc/g++-7/libstdc++` , повелители командной строки набирают `man 3 std::smth` )

```# apt install gcc-7-base g++-7 libgcc-7-dev libstdc++-7-dev libstdc++-7-doc```

Пишем hello world C++17-style ([источник][2])

```cpp
//1.cpp
#include <iostream>

int main()
{
  std::string str = "hello";
  char *p = str.data(); // С++17
  p[0] = 'H';
  std::cout << str << '\n'; // Hello

  return 0;
}
```

Компилируем и соберём исполняемый файл, проверяем что получилось.

```bash
$ g++-7 -o exe 1.cpp -g -std=c++17
$ ./exe
Hello
```

В принципе, можно работать, если вас устраивает следующий цикл: сохранить изменения, выйти из текстового редактора, получить и запустить исполняемый файл двумя командами (легко объединяются в одну с помощью _&&_ ).

Для сокращения числа рутинных операций задействуем утилиту _make_, которая знает как создавать одни файлы(цели) на основе других(зависимостей) по заданным правилам. Перед выполнением правила _make_ убедится, что указанные зависимости а) существуют как одноимённые файлы или б) существуют правила, на основе которых такие файлы могут быть получены и применит их (так обычно получаются недостающие библиотеки-зависимости перед сборкой исполняемого файла). Кроме того, _make_ проанализирует время обновления зависимостей и не будет предпринимать никаких действий, если целевой файл обновлялся позже любого файла, от которого зависит.

```make
#makefile naive
exe: 1.cpp makefile               #1
	g++-7 -o exe 1.cpp -std=c++17 #2
	./exe                         #3
```

На первой строке объявляем цель _exe_, зависящую от файлов _1.cpp_ и _makefile_, теперь для сборки и исполнения файла _exe_ достаточно набрать _make exe_. Так как _exe_ - первая цель в нашем _makefile_, то можно даже набирать просто _make_. На второй и третьей строке записаны правила, следуя которым мы получим нужный файл и проведём над ним какие-то действия.

Вышеописанный мэйкфайл достаточно наивен. Например, слово _exe_ встречается трижды - а вдруг нам понадобится изменить имя итогового файла? Или например, нужно будет скомпилировать не один, а несколько исходных файлов - придётся дублировать список зависимостей в строке правил? Для решения этих проблем воспользоваться переменными _make_, ну и добавим пару фишечек.

```make
#makefile ok
.PHONY: exe                    #1
exe: 1.cpp                     #2
	@g++-7 -o $@ $< -std=c++17 #3
	@./$@                      #4
```

Построчный разбор мэйкфайла
1\. Объявим цель _exe_ фиктиной для того, чтобы каждый раз создавать файл _exe_ заново, даже если исходный файл _1.cpp_ и _makefile_ не менялись с момента создания последней версии _exe_. Это приемлемо для нашего однофайлового проекта, но не надо так делать на большом проекте, автоматическая проверка времени обновления зависимостей существенно ускоряет сборку. Польза ощущается при изменении каких-то внешних условий - например при экспериментах с заменами в системе версий подключаемой библиотеки. Мы обычно не указываем системные библиотеки в списке зависимостей, только в правилах, а если бы и указали, то это не помогло бы - чаще всего такие файлы были созданы задолго до наших экспериментов и _make_ не заметит разницы.
> В результате достижения фиктивноей цели не создаётся одноименный файл. Типичная фиктивная цель - _clean_, в которой описаны правила удаления временных файлов; команда ```make clean``` (обычно) не приводит к появлению файла _clean_ и не должна ориентироваться на время его создания, если такой файл уже существует. Другая типичная фиктивная цель - _all_, при её выполнении обычно собираются все целевые файлы, и она имеет первый порядковый номер. Фиктивная цель _может_ находиться в списке зависимостей.

2\. Т.к. цель _exe_ фиктивная(т.е. пересобирается _всегда_), то больше нет смысла следить за появлением изменений в _makefile_.
3 и 4. @ в начале строки убирает из стандартного вывода строки с выполняющимися командами (мы их уже настроили и нам больше незачем на них смотреть в стандарном выводе). Так же произошли замены: _exe_ -> _\$@_, эта переменная обозначает имя цели (мнемоника - @ похожа на мишень) и _1.cpp_ -> _\$<_, эта переменная обозначает первую зависимость из списка (мнемоники не знаю, всё время путаю с переменной _\$^_, которая раскрывается в полный список зависимостей). Переменных гораздо больше, но эти три - самые полезные.

Цикл сократился до "сохранить, выйти, _make_". Если вы пишете программы, которые с первого раза работают как надо - этого достаточно. Для обычных людей это не подходит, как минимум хорошо бы сопоставлять ошибки компиляции со строками, в которых они произошли. И тут всё упирается в возможности редактора. Вызов внешней процедуры можно прикрутить даже к _mcedit_, как я когда-то делал при разработке скрипта на _Perl_. В какой-то момент я закопал стюардессу, прошёл _vimtutor_ и полюбил _vim_ за его мощь и простоту. Оцените:
`:w | make`

В одно действие сохраняем файл и выполняем встроенный вызов команды _make_. Нет необходимости открывать\закрывать редактор. Если компилятор нашёл ошибки, то _vim_ начнёт работать в "режиме" _quickfix_ - сразу перейдёт к месту первой ошибки 2) в статусной строке выведет сообщение об ошибке, 3) команды `:cnext, :cprev, :clist` служат для перехода к следующей, предыдущей, полному списку ошибок (у всех команд _vim_ есть краткий синтаксис, здесь это `:cn, :cp, :cl` соответственно). Всё, можно творить, не выходя из редактора. При сборке настоящего проекта бывает полезным перенаправить поток ошибок _make_ в отдельный файл и а) просто открыть его в виме и переходить к ошибочным строчкам исходного кода по _gF_ или б) открыть его в режиме _quickfix_: `vim -q filename`.

PS
1. Наверняка существует плагин для _vim_, который делает всё нижеописанное описанное и даже больше. На работе мне приходится работать на разных серверах под различными учётными записями, поэтому (в лучшем случае) я таскаю за собой свой _.vimrc_, и не обрастаю плагинами.
2. _vim_ и _make_ очень мощные инструменты, я не описал и доли их настоящих возможностей. Не пожалейте 10 минут и пройдите обучение: выполните ```$ vimtutor ru``` и следуйте указаниям. Хорошей отправной точкой в изучении _make_ может стать хабрапост ["Просто о make"][3].
2. Отладкой в консоли мне пока заниматься не доводилось, редко-редко запускаю _gdb_ по _ssh_. Увы, принты и голова - наше всё %)
3. Иркина программа считывала данные из входного потока, это можно автоматизировать следующим образом: `$ echo 1 2 | ./exe`. Если из большого вывода программы нас интересует малая часть, то фильтруем его `$ ./exe | grep smth`. Хорошо бы пользоваться юнит-тестированием, а для настоящих проектов пользоваться _cmake_ и _ctest_.
4. Для интерпретируемых ЯП (_Python, Perl, Bash, ..._) удобно играться с отдельными кусками вновь написаного кода, отправляя их в интерпретатор, открытый в соседнем окне мультиплексоров терминала _tmux_ или _screen_, см. [плагин vim-slime][4].

[1]: https://www.coursera.org/learn/c-plus-plus-white
[2]: https://habrahabr.ru/company/pvs-studio/blog/340014/ 
[3]: https://habrahabr.ru/post/211751/
[4]: https://www.youtube.com/watch?v=fWKIVWEhyG4
